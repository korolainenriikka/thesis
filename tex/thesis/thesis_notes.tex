\documentclass{article}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{geometry}
\usepackage[style=numeric,bibstyle=numeric,backend=biber,natbib=true,maxbibnames=99,giveninits=true,uniquename=init]{biblatex}
\usepackage[utf8]{inputenc}

\addbibresource{../bibliography.bib}
\title{Thesis notes}

\begin{document}

\tableofcontents

\section{Introduction}

\section{background}

\subsection{neural networks and deep learning}
keywords to explain (maybe) from \cite{li2021trocr}
- knowledge distillation
- generalist models
	- large unsupervised training data sets
- transformers
- cnns
- deep neural networks
- self attention
- convolution
- transfer learning
- encoder/decoder
- model compression
- loss functions
	- cross-entropy 
- data augmentation
- training/validation/test data sets
- learning rate
- batch size
- tokenizing
- image patches
- self-attention
- multi-head self-attention
- performance metrics
	- precision
	- recall 
	- f1

\subsection{paleoecology}

This section will have a summary on what fossil data can be used for.

the why: why do this at all? why is accurate dental data relevant, in general?

\subsubsection{Basics on ecology}

Nature is highly complicated -> models, approximate laws and assumptions enable drawing conclusions from
known distributions of species. Assumptions hold usually, not always, in reality but need to be in place 
because nothing could be known without them

Tolerances and niches (fundamental + realized): basis for environmental reconstruction \cite{Faith_Lyman_2019} ch 2

Assume that nearest living relative has same tolerances now -> get past environment (ch3)

Presence/absence/abundance: (ch3) species living somewhere -> environment matches the fundamental niche. absent more complicated,
environment may or may not be suitable (eg a fossil sample was simply not found). abundance estimation harder, but more
fine-resolution environmental analysis

transfer function: paleobiotic data -> environment (ch2)

environment is constructed with a coarse resolution such as how many 10cm's of precipitation (ch2)

Theory that the data analysis relies on

\subsubsection{Paleoenvironmental reconstruction}

maybe, how the data is used (this maybe overlaps with previous)

\subsubsection{Diets, evolution, etc}

maybe, how the data is used

\subsubsection{Dental fossils}

Fossils occur when animal / plant remains are deposited in a sediment in a way that preserves 
some part of its original form. Since teeth are the hardest material in animals, large fraction
of found parts are teeth.

Add here description of teeth: types and different notation styles in fossil catalogues

\section{data methods etc}

\subsection{data description}

\subsubsection{Notes on creating the dataset}

Hand-labeled

Data was extracted from scans by getting bounding boxes from Azure Vision API,
finding the correct column (nature of specimen or element), and cropping the image 
according to bounding boxes.

Non-tooth samples were not discarded since they contain 
bone fossil related words and good samples of the handwriting style of this dataset.

smudged-over "L" was labeled as "R", and other way around: it seems that later 
someone found it was the opposite side after all. Hope of this is that the model 
would learn to map "messy L" as "R". snudged "left" or "right" was not noted as the 
opposite as there were too few such samples.

Superscript seems much more rare than lower script

Data was labeled not by individual characters but as full tooth descriptions
to preserve context where tooth special characters are more likely to occur

Some have been corrected by writing on top and thus are very hard 
even for humans to read, this is also an example of smudged-over correction: 

\includegraphics*[scale=0.2]{superambiguous_data_sample.png}

\subsubsection{Unicode characters used for data labeling}

explain: unicode has graphenes with code points. eg a is one graphene one code point,
Ã  is one graphene two code points (dot on top and the letter). the top thing -like characters will be called 
"modifiers".

markings contain letters and numbers with no line, line on top or line at the bottom.
Each character can be lower- or upper script. The modifiers used are: 
macron with lower ($\bar{\mathrm{A}}$) and upper variant.

Unicode \cite{unicode_homepage} has characters that are for example upper script, but 
these were not used for two reasons:

- lower and upper script character set is incomplete for this purpose (eg 3 with upper macron and lower script needed)

- from the model perspective 3 and $_3$ are no more similar than A and B, however, 
three combined with lower script modifier and 3 with upper script modifier 
all contain the same unicode character 3 with only the modifier changing. The 
problem here is that there is no lower or upper case modifiers in unicode. Therefore,
the caron ($\check{\mathrm{A}}$) was chosen as the lower script modifier, and the circumflex accent ($\hat{\mathrm{A}}$)
as upper script. These were chosen since the arrow-like modifier pointing up or down
is maybe the most logical placeholder for the missing modifier. More traditional 
workarounds of missing upper or lower script, the underscore "\_" and separate 
caret character "\^ " were not used to keep one unicode graphene represent one character 
on the page. Also on the other hand using one modifier for all lowercase characters allows 
the model to understand that there is a similarity between all lowercase characters.
The intention is that one idea about a character is encoded as one code point, so that 
the model can learn the mapping from the image of the character to the code point 
combination

\section{results}

\section{conclusion}

\printbibliography

\end{document}